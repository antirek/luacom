<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html><head><title>LuaCOM: реализация объектов COM и элементов управления ими в Lua</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="StyleSheet" href="common_css.css">
<script type="text/javascript" src="script.js"></script>
<object id=hhctrl classid="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11" width=0 height=0 vspace=0 hspace=0 border=0 type="application/x-oleobject"></object>
</head>
<body>
<div class="post translation shortcuts_item">
<div class="content html_format">
<a name="4"></a>
<div class="head0"><h1 class="title"><font size=5>Глава 4</font></h1></div>
<h3>Реализация объектов COM и элементов управления ими в Lua</h3>
<a name="4.1"></a>
<h4>4.1 Введение</h4>
С LuaCOM возможно реализация полноценных COM объектов и элементов управления (контролов) OLE, использующих Lua.
Здесь мы понимаем COM объект как состоящий из следующих частей:
<ul><li>сервер, который реализует один или более COM объектов;</li>
<li>данные реестра, связывающие идентификатор класса CLSID (Class ID) с триадой (сервер, библиотека типов, интерфейс по умолчанию);</li>
<li>программный идентификатор (ProgID) (Programmatic Identifier), который является именем связанным с CLSID;</li>
<li>библиотека типов, содержащая элемент CoClass.</li></ul>
Данные реестра привязывают ProgID к CLSID, который, в свою очередь, сопоставляется с сервером. Сведения о типе описывают компонент - то есть, какие интерфейсы он предоставляет и каков его интерфейс по умолчанию.<br><br>
LuaCOM упрощает эти задачи, предоставляя некоторые вспомогательные функции для работ по регистрации и инстанцированию COM серверов.
LuaCOM поддерживает как <a class=popupspot href="JavaScript:hhctrl.TextPopup('out-of-process server, реализованный в виде ЕХЕ-модуля и выполняемый вне адресного пространства клиента - на той же или на удаленной машине.','Arial,9',10,10,0xffffff,0xd69967)">локальные, внепроцессные (EXE)</a>, так и <a class=popupspot href="JavaScript:hhctrl.TextPopup('server in-process внутрипроцессный сервер; сервер &quot;в процессе&quot; (в COM-технологиях - тип сервера, который реализуется как DLL, исполняемая в том же процессе, что и клиент)','Arial,9',10,10,0xffffff,0xd69967)">внутрипроцессные (DLL)</a> серверы.<br><br>
LuaCOM также предоставляет вспомогательные функции для регистрации и инстанцирования (создания экземпляра) элементов управления OLE (со своим пользовательским интерфейсом, встраиваемым в основную программу - <a class=popupspot href="JavaScript:hhctrl.TextPopup('хостинг-приложение, приложение-контейнер\r\nприложение, создающее среду для размещения другого приложения','Arial,9',10,10,0xffffff,0xd69967)">хостинг-приложение</a>).
Этому типу объекта требуется внутрипроцессный сервер и поддерживаемый набор инструментов Lua GUI (на сегодняшний день это <a class=popupspot href="JavaScript:hhctrl.TextPopup('Кроссплатформенная библиотека базовых элементов графического пользовательского интерфейса с использованием языков C и Lua. С его помощью можно создавать быстрые, не требующие компиляции графические приложения.','Arial,9',10,10,0xffffff,0xd69967)">IUP</a>).
<a name="4.2"></a>
<h4>4.2 Полезно ли это в действительности?</h4>
Кто-то может доказывать, что лучше бы было реализовать COM-объект на языках вроде C++ или Visual Basic<sup>&#174;</sup>.
Во многих ситуациях это правильно, но неверно в некоторых других.
Во-первых, работа с COM не так проста, а LuaCOM скрывает большинство его сложностей;
кроме того, имеется еще одна убедительная причина для использования LuaCOM по крайней мере в некоторых ситуациях:
семантика таблиц Lua и способ реализации LuaCOM позволяет делать некоторые вещи очень аккуратно:
<ul><li>для выставления в качестве COM-объекта любого объекта, который может быть доступен с помощью Lua через таблицу. Это могут быть объекты <a class=popupspot href="JavaScript:hhctrl.TextPopup('(обычно произносится &quot;кОрба&quot;; от англ. Common Object Request Broker Architecture — общая архитектура брокера объектных запросов) — технологический стандарт написания распределённых приложений, продвигаемый консорциумом (рабочей группой) OMG и соответствующая ему информационная технология.','Arial,9',10,10,0xffffff,0xd69967)">CORBA</a>, объекты C++, структуры языка C, код на Lua, и т.д.
Используя эту функцию, наследуемое приложение или библиотека могут быть "улучшены" до мира COM с небольшой дополнительной обработкой;</li>
<li>для использования COM-объектов везде, где предполагается Lua таблица. Например, COM-объект может быть "экспортирован" как объект CORBA, доступный через сеть;</li>
<li>для добавления и переопределения методов экземпляра COM-объекта.
Это может быть очень полезно в предыдущих ситуациях: объект интереса может быть дополнен и затем экспортирован другому клиенту.</li></ul>
Конечно, вся эта гибкость имеет свою цену, в первую очередь сказывается на производительности. Впрочем, зависит от приложения, нехватка производительности может быть ничтожно мала.<br><br>
LuaCOM не решает всех проблем: остается потребность в библиотеке типов, которая должна быть создана с использованием сторонних инструментов.
<a name="4.3"></a>
<h4>4.3 Терминология</h4>
Во избежание недоразумений, тут представлены значения, которые мы даем некоторым терминам, используемым в данной главе.
Мы не даем здесь официальных определений: мы просто хотим облегчить понимание некоторых концепций. Чтобы лучше представлять эти понятия смотрите COM документацию.<br><br>
<b>Component (компонент, деталь, составная часть)</b> - часть программного обеспечения с некоторой функциональностью, которая может быть использована другими компонентами. Он состоит из набора объектов, что реализуют данную функциональность.<br><br>
<b>Component Object (составной объект)</b> - объект, через который можно получать все функциональные возможности компонента, включая другие его объекты. Данный объект может иметь много интерфейсов.<br><br>
<b>Application Object (объект-приложение)</b> Составной объект с интерфейсом, который содержит все высокоуровневые функциональные возможности компонента; клиенту не нужно использовать другие интерфейсы составного объекта.
Такое представление упрощает понимание компонента, поскольку размещает все свои функциональные возможности в иерархическом порядке
(объект-приложение вместе со своими вложенными объектами, которые могут быть доступны только через методы и свойства объекта-приложения).<br><br>
<b>COM server (COM сервер)</b> Некоторая часть кода, что реализует (имплементирует) один или более составных объектов. COM сервер должен сообщить другим приложениям и компонентам какие составные объекты он делает доступными. Он делает это, выставляя (показывая) их.<br><br>
<b>OLE control (элемент управления OLE)</b> Объект, имеющий пользовательский интерфейс, который может быть встроен внутрь других приложений, имеющих OLE контейнеры (обычно приложения на C++ или Visual Basic).<br><br>
<b>CoClass (от component object class - класс составного объекта)</b> Библиотека типов описывающая компонент, обязанный иметь соответствующую запись CoClass, определяющую некоторые сведения о компоненте:
<ul><li>имя, отличающее один CoClass от других, в одной и той же библиотеке типов;</li>
<li>свой CLSID (идентификатор класса), уникальный идентификатор, который служит отличительным признаком данного компонента от всех остальных;</li>
<li>интерфейсы составного объекта, сообщающие который из них является интерфейсом по умолчанию.
В обычной ситуации, будет предоставлен только один интерфейс; поэтому составной объект может быть вызван объектом-приложением для данного компонента;</li>
<li>исходный интерфейс — то есть, интерфейс компонента используемый для отправки событий клиенту.
Этот интерфейс не реализуется (имплементируется) компонентом: он просто использует объекты, которые реализуют (имплементируют) данный интерфейс.</li></ul>
<b>Lua Application Object (объект-приложение Lua)</b> Это Lua таблица, используемая для реализации (имплементации) объекта-приложения.
<a name="4.4"></a>
<h4>4.4 Построение COM сервера в LuaCOM</h4>
Для построения COM сервера с помощью LuaCOM имеется несколько шагов:
<ol><li>определение компонента;</li>
<li>определяем, что собираемся экспортировать: объект-приложение Lua и его вложенные объекты;</li>
<li>создаем библиотеку типов для компонента;</li>
<li>определяем сведения для регистрации компонента;</li>
<li>регистрируем объект компонент;</li>
<li>реализуем (имплементируем) и выставляем COM-объекты;</li>
<li>добавляем инициализацию COM и код завершения.</li></ol>
<a name="4.4.1"></a>
<h5>4.4.1 Определение компонента</h5>
Это первый шаг: устанавливаем какие функциональные возможности компонента будут выставлены. Эта функциональность представляется иерархическим порядком объектов, начинающимся с объекта-приложения. Каждый из этих объектов должен реализовывать интерфейс.<br><br>
<b>Пример</b>:&nbsp; &nbsp;Предположим, что у нас есть библиотека Lua которая реализует доступ к базам данных, содержащих в конкретной СУБД.
Эта библиотека имеет три типа объектов: базы данных, запросы и отчеты. В мире COM, это можно представить объектом-приложением, который открывает базы данных и возвращает объект Database.
Объект Database имеет, среди прочего, метод Query (запрос). Этот метод принимает SQL предложение и возвращает объект Query.
Объект Query является коллекцией (сборником), которая может быть итерирована (повторно обработана) с использованием параметризованного свойства Records, что возвращает объект типа Record.
<a name="4.4.2"></a>
<h5>4.4.2 Объекты для экспорта</h5>
Экспортируемые объекты - это те, что входят в состав иерархического порядка базирующегося на объекте-приложении (Application object).
В мире языка Lua объекты обычно представлены в виде таблиц или пользовательских данных (userdata). (Здесь таблицы и пользовательские данные - это типы данных, принятых в Lua. - <i>примечание переводчика</i>)
Таким образом, это необходимо для идентификации (или реализации) таблиц Lua, используемых для реализации экспортируемых объектов.
<a name="4.4.3"></a>
<h5>4.4.3 Создание библиотеки типов</h5>
Библиотека типов должна содержать записи для всех интерфейсов экспортируемых объектов и запись для CoClass, определяющего интерфейс объекта-приложения и интерфейса, используемого для отправки событий.<br><br>
Наиболее распространенным способом создания библиотеки типов является написание <a class=popupspot href="JavaScript:hhctrl.TextPopup('от Interface Definition Language - язык описания интерфейсов (используется в COM -технологиях для спецификации интерфейсов объектов COM)','Arial,9',10,10,0xffffff,0xd69967)">IDL</a> описание библиотеки типов и затем использовать IDL компилятор, такой как MIDL от Microsoft<sup>&#174;</sup>.
Обратите внимание что, все интерфейсы должны быть <a class=popupspot href="JavaScript:hhctrl.TextPopup('осуществляет доступ к сервисам COM-объектов в OLE Automation','Arial,9',10,10,0xffffff,0xd69967)">диспетчерскими интерфейсами</a> — то есть, должны наследовать от <tt>IDispatch</tt> и должны иметь флаг <tt>oleautomation</tt>.
<a name="4.4.4"></a>
<h5>4.4.4 Регистрационные сведения</h5>
Здесь следует указать сведения, используемые COM для обнаружения компонента. Смотрите документацию по <a href="reference.htm#RegisterObject">RegisterObject</a>.
<a name="4.4.5"></a>
<h5>4.4.5 Регистрация объекта Component</h5>
Перед тем как стать доступным для других приложений, объект компонент должен быть зарегистрирован в реестре системы.
Это можно сделать с помощью функции API <a href="reference.htm#RegisterObject">RegisterObject</a>. Данная функция получает таблицу с регистрационными сведениями объекта.
Посмотрите поля этой таблицы в <a href="#4.7">Полнофункциональном примере</a>.
<a name="4.4.6"></a>
<h5>4.4.6 Реализация и выставление компонента</h5>
Имеются две различные ситуации, требующие разных действий:<br><br>
<b>Реализация (имплементация) объекта-приложения</b> Тут нужно использовать LuaCOM метод <tt>NewObject</tt> для создания объекта COM с привязкой его к таблице объекта-приложения Lua (Lua Application Object).
Затем этот объект нужно сделать доступным (выставить его) для других приложений с помощью <tt>ExposeObject</tt>.<br><br>
<b>Реализация (имплементация) других объектов</b> Другие объекты компонента получаются от объекта-приложения Lua в качестве возвращаемых значений функций или как значения, хранящиеся в полях объекта-приложения Lua (то есть, через доступ к свойству).
Эти объекты реализуются с помощью <tt>ImplInterface</tt>.
Они могут быть реализованы при инициализации (и затем где-то храниться) или могут реализовываться по потребности (то есть, каждый раз при возвращении COM-объекта делается вызов <tt>ImplInterface</tt>).<br><br>
Обратите внимание, что поля Lua-таблицы, используемые для реализации компонента COM, будут доступны, только если они представлены в библиотеке типов. Если это не так, то они будут невидимы для COM.
<a name="4.4.7"></a>
<h5>4.4.7 Инициализация и завершение</h5>
<h6>Инициализация</h6>
Если был реализован свой собственный сервер, вместо использования встроенной поддержки, то он должен вызывать функции инициализации COM (<tt>OleInitialize</tt> или <tt>CoInitialize</tt>) перед запуском LuaCOM.
Другой задачей инициализации является реализация и представление COM объектов.
Эта задача может быть значительно упрощена использованием функции C/C++ API LuaCOM <tt>luacom_detectAutomation</tt>.<br><br>
Если же нужно использовать встроенную поддержку, инициализация необходима только для вызова функции API <tt>DetectAutomation</tt> в конце скрипта, который
реализует объекты, передавая таблицу с методами для регистрации и выставления объектов.
<h6>Завершение</h6>
COM сервер должен вызывать (в Lua) функцию <tt>RevokeObject</tt> для каждого представленного объекта. Затем он должен вызвать функции завершения COM, ПОСЛЕ  вызова <tt>lua_close</tt>; в противном случае могут возникать фатальные ошибки.
<a name="4.5"></a>
<h4>4.5 Запуск COM сервера</h4>
COM сервер выстроенный по представленным рекомендациям может использоваться как любой другой COM-объект — то есть, используя <tt>CoCreateInstance</tt>, <tt>CreateObject</tt> или подобные им.
<a name="4.6"></a>
<h4>4.6 Создание событий</h4>
Метод <tt>NewObject</tt> возвращает точку подключения объекта-контейнера. Этот объект позволяет компоненту отправлять события своим клиентам простым вызовом методов на этом объекте, передавая ожидаемые параметры.
Возвращение значений пока не разрешено.
<a name="4.7"></a>
<div><h4>4.7 Полнофункциональный пример</h4>
Здесь дан пример полнофункционального Lua COM сервера. В примере предполагается что этот скрипт называется <tt>testobj.lua</tt>:<div>
<input type="button" value="(показать)" class="link" onclick="javascript:spoiler(this)"/></div>
<div style="display:none;">
<pre><code>-- This is the implementation of the COM object
-- Реализация объекта COM
path_to_obj = "\\Path\\To\\Script\\"<br>
TestObj = &#123;&#125;<br>
function TestObj:showWindow()
  print("Show!")
  events:OnShow()
end<br>
function TestObj:hideWindow()
  print("Hide!")
  events:OnHide()
end<br>
COM = &#123;&#125;<br>
function COM:StartAutomation()
  -- creates the object using its default interface
  -- создаем объект, используя его интерфейс по умолчанию
  COMAppObject, events, e = luacom.NewObject(TestObj, "TEST.Test")
  -- This error will be caught by detectAutomation
  -- Эта ошибка будет выловлена detectAutomation
  if COMAppObject == nil then
    error("NewObject failed: "..e)
  end
  -- Exposes the object
  -- Предоставляем объект
  cookie = luacom.ExposeObject(COMAppObject)
  if cookie == nil then
    error("ExposeObject failed!")
  end
end<br>
function COM:Register()
  -- fills table with registration information
  -- заполняем таблицу с регистрационными сведениями
  local reginfo = &#123;&#125;
  reginfo.VersionIndependentProgID = "TEST.Test"
  reginfo.ProgID = reginfo.VersionIndependentProgID..".1"
  reginfo.TypeLib = "test.tlb"
  reginfo.CoClass = "Test"
  reginfo.ComponentName = "Test Component"
  reginfo.Arguments = "/Automation"
  reginfo.ScriptFile = path_to_script .. "testobj.lua"
  -- stores component information in the registry
  -- сохраняем сведения о компонентах в реестре
  local res = luacom.RegisterObject(reginfo)
  if res == nil then
    error("RegisterObject failed!")
  end
end<br>
function COM:UnRegister()
  -- fills table with registration information
  -- заполняем таблицу с регистрационными сведениями
  local reginfo = &#123;&#125;
  reginfo.VersionIndependentProgID = "TEST.Test"
  reginfo.ProgID = reginfo.VersionIndependentProgID..".1"
  reginfo.TypeLib = "test.tlb"
  reginfo.CoClass = "Test"
  -- removes component information from the registry
  -- удаляем сведения о компонентах из реестра
  local res = luacom.UnRegisterObject(reginfo)
  if res == nil then
    error("UnRegisterObject failed!")
  end
end<br>
-- Starts automation server
-- Запуск сервера автоматизации
return luacom.DetectAutomation(COM)</code></pre></div></div>
<a name="4.8"></a>
<h4>4.8 Построение элементов управления OLE Lua</h4>
Большинство из того, что требуется для построения элемента управления (контрола) OLE уже было описано в предыдущей главе.
Элементы управления подобны обычным объектам LuaCOM, но создаются при помощи функции API <tt>NewControl</tt> вместо <tt>NewObject</tt>. Таблица регистрационных сведений также должна иметь поле <tt>Control</tt>, установленное как <i>true</i>.<br><br>
Таблица реализующая элемент управления (контрол) также должна реализовывать несколько дополнительных методов, часть протокола контрола. Это следующие:<br><br>
<b>InitialSize</b>&nbsp; &nbsp; Контрол может использовать этот метод для возвращения своего первоначального размера, в пикселах.<br><br>
<b>CreateWindow</b>&nbsp; &nbsp; Вызывается когда контрол создает свое окно. Параметрами этой функции являются дескриптор (handle - хэндл) родительского окна (в виде пользовательских данных - userdata), начальное положение и первоначальный размер окна.
Контрол должен возвратить пользовательские данные со своим дескриптором окна.<br><br>
<b>SetExtent</b>&nbsp; &nbsp; Вызывается всякий раз, когда основное приложение (хост) хочет изменить размеры элемента управления (контрола). Параметрами являются новые размеры. Должен возвращать значение <i>true</i>, если контрол принимает изменение размера, в противном случае возвращается значение <i>false</i>.<br><br>
<b>GetClass</b>&nbsp; &nbsp; должен возвращать идентификатор класса (class id) элемента управления (контрола).<br><br>
<b>DestroyWindow</b>&nbsp; &nbsp; Вызывается когда основная программа завершила работу с контролом и он (контрол) должен уничтожить свое окно и высвободить все занимаемые ресурсы.<br><br>
На домашней странице LuaCOM, в директории <a href="https://github.com/davidm/luacom/tree/master/demo/control" target=_blank>demo/control</a> имеется пример элемента управления (контрола).<br><br>
<hr width=90%>
<div align=center style="margin-left:5%; margin-right:5%;">LuaCOM был разработан Renato Cerqueira, Vinicius Almendra и Fabio Mascarenhas.<br>
Проект финансируется компанией TeCGraf<br>(Technology Group on Computer Graphics).
</div></div></div>
<br><br>
</body>
</html>